{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to PGx Toolkit","text":"<p>PGx Toolkit is a Python package designed for personalized pharmacogenomic network analysis. It bridges the gap between raw genotype data and pharmacogenomic knowledge bases to uncover actionable insights through network science.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Genotype Parsing: Efficiently reads 23andMe raw data formats.</li> <li>Annotation Mapping: Links variants to PharmGKB drug annotations.</li> <li>Network Construction: Builds a graph where nodes are Genes and Drugs, and edges represent pharmacogenomic interactions.</li> <li>Centrality Analysis: Identifies key drivers in your personal pharmacogenomic landscape.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To install the package:</p> <pre><code>pip install .\n</code></pre> <p>See the API Reference for detailed usage.</p>"},{"location":"api/annotation/","title":"Annotation Module","text":""},{"location":"api/annotation/#pgx_toolkit.core.annotation.PharmGKB","title":"<code>PharmGKB</code>","text":"Source code in <code>pgx_toolkit/core/annotation.py</code> <pre><code>class PharmGKB:\n    def __init__(self, annotations=None):\n        self.annotations = annotations if annotations is not None else []\n        # Index by rsID for faster lookup. Note: One rsID can have multiple annotations.\n        self._annotation_map = {}\n        for ann in self.annotations:\n            if ann.rsid not in self._annotation_map:\n                self._annotation_map[ann.rsid] = []\n            self._annotation_map[ann.rsid].append(ann)\n\n    def get_annotations(self, rsid):\n        return self._annotation_map.get(rsid, [])\n\n    @classmethod\n    def from_tsv(cls, filepath):\n        \"\"\"\n        Parses the PharmGKB variant annotation TSV file.\n        Expected columns include 'Variant/Haplotypes', 'Gene', 'Drug(s)', etc.\n        \"\"\"\n        annotations = []\n        try:\n            df = pd.read_csv(filepath, sep='\\t', dtype=str)\n\n            # Regex to extract rsID\n            rsid_pattern = re.compile(r\"rs[0-9]+\")\n\n            for _, row in df.iterrows():\n                variant_text = str(row.get('Variant/Haplotypes', ''))\n                match = rsid_pattern.search(variant_text)\n                if match:\n                    rsid = match.group(0)\n\n                    # Create annotation object\n                    ann = DrugAnnotation(\n                        rsid=rsid,\n                        gene=row.get('Gene', ''),\n                        drug=row.get('Drug(s)', ''),\n                        phenotype_category=row.get('Phenotype Category', ''),\n                        significance=row.get('Significance', ''),\n                        notes=row.get('Notes', ''),\n                        sentence=row.get('Sentence', ''),\n                        alleles=row.get('Alleles', '')\n                    )\n                    annotations.append(ann)\n\n        except Exception as e:\n            print(f\"Error loading PharmGKB file: {e}\")\n            raise\n\n        return cls(annotations)\n\n    def __len__(self):\n        return len(self.annotations)\n</code></pre>"},{"location":"api/annotation/#pgx_toolkit.core.annotation.PharmGKB.from_tsv","title":"<code>from_tsv(filepath)</code>  <code>classmethod</code>","text":"<p>Parses the PharmGKB variant annotation TSV file. Expected columns include 'Variant/Haplotypes', 'Gene', 'Drug(s)', etc.</p> Source code in <code>pgx_toolkit/core/annotation.py</code> <pre><code>@classmethod\ndef from_tsv(cls, filepath):\n    \"\"\"\n    Parses the PharmGKB variant annotation TSV file.\n    Expected columns include 'Variant/Haplotypes', 'Gene', 'Drug(s)', etc.\n    \"\"\"\n    annotations = []\n    try:\n        df = pd.read_csv(filepath, sep='\\t', dtype=str)\n\n        # Regex to extract rsID\n        rsid_pattern = re.compile(r\"rs[0-9]+\")\n\n        for _, row in df.iterrows():\n            variant_text = str(row.get('Variant/Haplotypes', ''))\n            match = rsid_pattern.search(variant_text)\n            if match:\n                rsid = match.group(0)\n\n                # Create annotation object\n                ann = DrugAnnotation(\n                    rsid=rsid,\n                    gene=row.get('Gene', ''),\n                    drug=row.get('Drug(s)', ''),\n                    phenotype_category=row.get('Phenotype Category', ''),\n                    significance=row.get('Significance', ''),\n                    notes=row.get('Notes', ''),\n                    sentence=row.get('Sentence', ''),\n                    alleles=row.get('Alleles', '')\n                )\n                annotations.append(ann)\n\n    except Exception as e:\n        print(f\"Error loading PharmGKB file: {e}\")\n        raise\n\n    return cls(annotations)\n</code></pre>"},{"location":"api/annotation/#pgx_toolkit.core.annotation.DrugAnnotation","title":"<code>DrugAnnotation</code>","text":"Source code in <code>pgx_toolkit/core/annotation.py</code> <pre><code>class DrugAnnotation:\n    def __init__(self, rsid, gene, drug, phenotype_category, significance, notes, sentence, alleles):\n        self.rsid = rsid\n        self.gene = gene\n        self.drug = drug\n        self.phenotype_category = phenotype_category\n        self.significance = significance\n        self.notes = notes\n        self.sentence = sentence\n        self.alleles = alleles\n\n    def __repr__(self):\n        return f\"DrugAnnotation(rsid='{self.rsid}', gene='{self.gene}', drug='{self.drug}')\"\n</code></pre>"},{"location":"api/genotype/","title":"Genotype Module","text":""},{"location":"api/genotype/#pgx_toolkit.core.genotype.UserGenotype","title":"<code>UserGenotype</code>","text":"Source code in <code>pgx_toolkit/core/genotype.py</code> <pre><code>class UserGenotype:\n    def __init__(self, entries=None):\n        self.entries = entries if entries is not None else []\n        self._entry_map = {e.rsid: e for e in self.entries}\n\n    def add_entry(self, entry):\n        self.entries.append(entry)\n        self._entry_map[entry.rsid] = entry\n\n    def get_entry(self, rsid):\n        return self._entry_map.get(rsid)\n\n    @classmethod\n    def from_23andme(cls, filepath):\n        \"\"\"\n        Parses a 23andMe raw data file.\n        Assumes standard 23andMe format (header lines start with #).\n        Columns: rsid, chromosome, position, genotype\n        \"\"\"\n        entries = []\n        try:\n            # Read file, skipping comments\n            df = pd.read_csv(filepath, sep='\\t', comment='#', header=None, \n                             names=['chromosome', 'position', 'rsid', 'genotype'],\n                             dtype={'rsid': str, 'chromosome': str, 'position': int, 'genotype': str})\n\n            for _, row in df.iterrows():\n                entry = GenotypeEntry(row['rsid'], row['chromosome'], row['position'], row['genotype'])\n                entries.append(entry)\n\n        except Exception as e:\n            print(f\"Error loading 23andMe file: {e}\")\n            raise\n\n        return cls(entries)\n\n    def __len__(self):\n        return len(self.entries)\n</code></pre>"},{"location":"api/genotype/#pgx_toolkit.core.genotype.UserGenotype.from_23andme","title":"<code>from_23andme(filepath)</code>  <code>classmethod</code>","text":"<p>Parses a 23andMe raw data file. Assumes standard 23andMe format (header lines start with #). Columns: rsid, chromosome, position, genotype</p> Source code in <code>pgx_toolkit/core/genotype.py</code> <pre><code>@classmethod\ndef from_23andme(cls, filepath):\n    \"\"\"\n    Parses a 23andMe raw data file.\n    Assumes standard 23andMe format (header lines start with #).\n    Columns: rsid, chromosome, position, genotype\n    \"\"\"\n    entries = []\n    try:\n        # Read file, skipping comments\n        df = pd.read_csv(filepath, sep='\\t', comment='#', header=None, \n                         names=['chromosome', 'position', 'rsid', 'genotype'],\n                         dtype={'rsid': str, 'chromosome': str, 'position': int, 'genotype': str})\n\n        for _, row in df.iterrows():\n            entry = GenotypeEntry(row['rsid'], row['chromosome'], row['position'], row['genotype'])\n            entries.append(entry)\n\n    except Exception as e:\n        print(f\"Error loading 23andMe file: {e}\")\n        raise\n\n    return cls(entries)\n</code></pre>"},{"location":"api/genotype/#pgx_toolkit.core.genotype.GenotypeEntry","title":"<code>GenotypeEntry</code>","text":"Source code in <code>pgx_toolkit/core/genotype.py</code> <pre><code>class GenotypeEntry:\n    def __init__(self, rsid, chromosome, position, genotype):\n        self.rsid = rsid\n        self.chromosome = chromosome\n        self.position = position\n        self.genotype = genotype\n\n    def __repr__(self):\n        return f\"GenotypeEntry(rsid='{self.rsid}', genotype='{self.genotype}')\"\n</code></pre>"},{"location":"api/matcher/","title":"Matcher Module","text":""},{"location":"api/matcher/#pgx_toolkit.core.matcher.PGxMatcher","title":"<code>PGxMatcher</code>","text":"Source code in <code>pgx_toolkit/core/matcher.py</code> <pre><code>class PGxMatcher:\n    def __init__(self):\n        pass\n\n    def match(self, user_genotype: UserGenotype, pharmgkb: PharmGKB):\n        \"\"\"\n        Matches variants in the user's genotype with PharmGKB annotations.\n        Returns a list of MatchedVariant objects.\n        \"\"\"\n        matches = []\n\n        # Iterate through user's genotype entries\n        for entry in user_genotype.entries:\n            # Look up annotations for this rsID\n            annotations = pharmgkb.get_annotations(entry.rsid)\n\n            for ann in annotations:\n                # Basic matching logic: \n                # If the annotation exists for this rsID, we consider it a \"match\" in terms of \n                # \"this variant is relevant to this drug\".\n                # A more complex logic could check if the user's specific alleles match the 'Alleles' field in annotation,\n                # but for network analysis (Gene-Drug association), presence is the primary link.\n\n                # Filter for Significance=\"yes\" and Phenotype Category=\"Efficacy\" as per original notebook logic\n                # to focus on high-confidence, efficacy-related interactions.\n                if ann.significance == 'yes' and ann.phenotype_category == 'Efficacy':\n                     matches.append(MatchedVariant(entry, ann))\n\n        return matches\n</code></pre>"},{"location":"api/matcher/#pgx_toolkit.core.matcher.PGxMatcher.match","title":"<code>match(user_genotype, pharmgkb)</code>","text":"<p>Matches variants in the user's genotype with PharmGKB annotations. Returns a list of MatchedVariant objects.</p> Source code in <code>pgx_toolkit/core/matcher.py</code> <pre><code>def match(self, user_genotype: UserGenotype, pharmgkb: PharmGKB):\n    \"\"\"\n    Matches variants in the user's genotype with PharmGKB annotations.\n    Returns a list of MatchedVariant objects.\n    \"\"\"\n    matches = []\n\n    # Iterate through user's genotype entries\n    for entry in user_genotype.entries:\n        # Look up annotations for this rsID\n        annotations = pharmgkb.get_annotations(entry.rsid)\n\n        for ann in annotations:\n            # Basic matching logic: \n            # If the annotation exists for this rsID, we consider it a \"match\" in terms of \n            # \"this variant is relevant to this drug\".\n            # A more complex logic could check if the user's specific alleles match the 'Alleles' field in annotation,\n            # but for network analysis (Gene-Drug association), presence is the primary link.\n\n            # Filter for Significance=\"yes\" and Phenotype Category=\"Efficacy\" as per original notebook logic\n            # to focus on high-confidence, efficacy-related interactions.\n            if ann.significance == 'yes' and ann.phenotype_category == 'Efficacy':\n                 matches.append(MatchedVariant(entry, ann))\n\n    return matches\n</code></pre>"},{"location":"api/matcher/#pgx_toolkit.core.matcher.MatchedVariant","title":"<code>MatchedVariant</code>","text":"Source code in <code>pgx_toolkit/core/matcher.py</code> <pre><code>class MatchedVariant:\n    def __init__(self, genotype_entry, annotation):\n        self.genotype_entry = genotype_entry\n        self.annotation = annotation\n\n    @property\n    def rsid(self):\n        return self.genotype_entry.rsid\n\n    @property\n    def gene(self):\n        return self.annotation.gene\n\n    @property\n    def drug(self):\n        return self.annotation.drug\n\n    @property\n    def user_genotype(self):\n        return self.genotype_entry.genotype\n\n    def __repr__(self):\n        return f\"MatchedVariant(rsid='{self.rsid}', gene='{self.gene}', drug='{self.drug}', genotype='{self.user_genotype}')\"\n</code></pre>"},{"location":"api/network/","title":"Network Analysis Module","text":""},{"location":"api/network/#pgx_toolkit.analysis.network.InteractionNetwork","title":"<code>InteractionNetwork</code>","text":"Source code in <code>pgx_toolkit/analysis/network.py</code> <pre><code>class InteractionNetwork:\n    def __init__(self):\n        self.graph = nx.Graph()\n        self.matched_variants = []\n\n    def build_graph(self, matched_variants):\n        \"\"\"\n        Builds a bipartite-like graph from matched variants.\n        Nodes: Genes, Drugs\n        Edges: Interaction (annotated by rsID)\n        \"\"\"\n        self.matched_variants = matched_variants\n        self.graph.clear()\n\n        for mv in matched_variants:\n            gene = mv.gene\n            # Drugs field can contain multiple drugs separated by commas or other delimiters.\n            # We'll do simple splitting by comma for now.\n            drugs = [d.strip() for d in mv.drug.split(',')]\n\n            if not gene:\n                continue\n\n            # Add Gene Node\n            self.graph.add_node(gene, type='gene')\n\n            for drug in drugs:\n                if not drug:\n                    continue\n                # Add Drug Node\n                self.graph.add_node(drug, type='drug')\n\n                # Add Edge\n                # We can add weight or metadata to the edge (e.g., rsID count)\n                if self.graph.has_edge(gene, drug):\n                    self.graph[gene][drug]['weight'] += 1\n                    self.graph[gene][drug]['rsids'].append(mv.rsid)\n                else:\n                    self.graph.add_edge(gene, drug, weight=1, rsids=[mv.rsid])\n\n    def get_high_impact_genes(self, top_n=5):\n        \"\"\"\n        Returns top N genes by degree centrality (number of connected drugs).\n        \"\"\"\n        gene_nodes = [n for n, d in self.graph.nodes(data=True) if d.get('type') == 'gene']\n        degrees = {n: self.graph.degree(n) for n in gene_nodes}\n        sorted_genes = sorted(degrees.items(), key=lambda x: x[1], reverse=True)\n        return sorted_genes[:top_n]\n\n    def get_multigene_drugs(self, top_n=5):\n        \"\"\"\n        Returns top N drugs by degree centrality (number of connected genes).\n        \"\"\"\n        drug_nodes = [n for n, d in self.graph.nodes(data=True) if d.get('type') == 'drug']\n        degrees = {n: self.graph.degree(n) for n in drug_nodes}\n        sorted_drugs = sorted(degrees.items(), key=lambda x: x[1], reverse=True)\n        return sorted_drugs[:top_n]\n\n    def export_summary(self):\n        \"\"\"\n        Returns a DataFrame summarizing the network.\n        \"\"\"\n        data = []\n        for u, v, d in self.graph.edges(data=True):\n            # Determine which is gene and which is drug (graph is undirected)\n            node_u_type = self.graph.nodes[u].get('type')\n            if node_u_type == 'gene':\n                gene, drug = u, v\n            else:\n                gene, drug = v, u\n\n            data.append({\n                'Gene': gene,\n                'Drug': drug,\n                'Interaction_Count': d['weight'],\n                'rsIDs': ','.join(set(d['rsids']))\n            })\n\n        return pd.DataFrame(data)\n</code></pre>"},{"location":"api/network/#pgx_toolkit.analysis.network.InteractionNetwork.build_graph","title":"<code>build_graph(matched_variants)</code>","text":"<p>Builds a bipartite-like graph from matched variants. Nodes: Genes, Drugs Edges: Interaction (annotated by rsID)</p> Source code in <code>pgx_toolkit/analysis/network.py</code> <pre><code>def build_graph(self, matched_variants):\n    \"\"\"\n    Builds a bipartite-like graph from matched variants.\n    Nodes: Genes, Drugs\n    Edges: Interaction (annotated by rsID)\n    \"\"\"\n    self.matched_variants = matched_variants\n    self.graph.clear()\n\n    for mv in matched_variants:\n        gene = mv.gene\n        # Drugs field can contain multiple drugs separated by commas or other delimiters.\n        # We'll do simple splitting by comma for now.\n        drugs = [d.strip() for d in mv.drug.split(',')]\n\n        if not gene:\n            continue\n\n        # Add Gene Node\n        self.graph.add_node(gene, type='gene')\n\n        for drug in drugs:\n            if not drug:\n                continue\n            # Add Drug Node\n            self.graph.add_node(drug, type='drug')\n\n            # Add Edge\n            # We can add weight or metadata to the edge (e.g., rsID count)\n            if self.graph.has_edge(gene, drug):\n                self.graph[gene][drug]['weight'] += 1\n                self.graph[gene][drug]['rsids'].append(mv.rsid)\n            else:\n                self.graph.add_edge(gene, drug, weight=1, rsids=[mv.rsid])\n</code></pre>"},{"location":"api/network/#pgx_toolkit.analysis.network.InteractionNetwork.export_summary","title":"<code>export_summary()</code>","text":"<p>Returns a DataFrame summarizing the network.</p> Source code in <code>pgx_toolkit/analysis/network.py</code> <pre><code>def export_summary(self):\n    \"\"\"\n    Returns a DataFrame summarizing the network.\n    \"\"\"\n    data = []\n    for u, v, d in self.graph.edges(data=True):\n        # Determine which is gene and which is drug (graph is undirected)\n        node_u_type = self.graph.nodes[u].get('type')\n        if node_u_type == 'gene':\n            gene, drug = u, v\n        else:\n            gene, drug = v, u\n\n        data.append({\n            'Gene': gene,\n            'Drug': drug,\n            'Interaction_Count': d['weight'],\n            'rsIDs': ','.join(set(d['rsids']))\n        })\n\n    return pd.DataFrame(data)\n</code></pre>"},{"location":"api/network/#pgx_toolkit.analysis.network.InteractionNetwork.get_high_impact_genes","title":"<code>get_high_impact_genes(top_n=5)</code>","text":"<p>Returns top N genes by degree centrality (number of connected drugs).</p> Source code in <code>pgx_toolkit/analysis/network.py</code> <pre><code>def get_high_impact_genes(self, top_n=5):\n    \"\"\"\n    Returns top N genes by degree centrality (number of connected drugs).\n    \"\"\"\n    gene_nodes = [n for n, d in self.graph.nodes(data=True) if d.get('type') == 'gene']\n    degrees = {n: self.graph.degree(n) for n in gene_nodes}\n    sorted_genes = sorted(degrees.items(), key=lambda x: x[1], reverse=True)\n    return sorted_genes[:top_n]\n</code></pre>"},{"location":"api/network/#pgx_toolkit.analysis.network.InteractionNetwork.get_multigene_drugs","title":"<code>get_multigene_drugs(top_n=5)</code>","text":"<p>Returns top N drugs by degree centrality (number of connected genes).</p> Source code in <code>pgx_toolkit/analysis/network.py</code> <pre><code>def get_multigene_drugs(self, top_n=5):\n    \"\"\"\n    Returns top N drugs by degree centrality (number of connected genes).\n    \"\"\"\n    drug_nodes = [n for n, d in self.graph.nodes(data=True) if d.get('type') == 'drug']\n    degrees = {n: self.graph.degree(n) for n in drug_nodes}\n    sorted_drugs = sorted(degrees.items(), key=lambda x: x[1], reverse=True)\n    return sorted_drugs[:top_n]\n</code></pre>"},{"location":"api/viz/","title":"Visualization Module","text":""},{"location":"api/viz/#pgx_toolkit.viz.graph_plot.plot_network","title":"<code>plot_network(interaction_network, output_path)</code>","text":"<p>Generates a static plot of the gene-drug interaction graph.</p> Source code in <code>pgx_toolkit/viz/graph_plot.py</code> <pre><code>def plot_network(interaction_network, output_path):\n    \"\"\"\n    Generates a static plot of the gene-drug interaction graph.\n    \"\"\"\n    G = interaction_network.graph\n    if len(G.nodes) == 0:\n        print(\"Graph is empty. Nothing to plot.\")\n        return\n\n    plt.figure(figsize=(12, 12))\n\n    # Layout\n    pos = nx.spring_layout(G, k=0.3, iterations=50)\n\n    # Separate nodes by type for coloring\n    gene_nodes = [n for n, d in G.nodes(data=True) if d.get('type') == 'gene']\n    drug_nodes = [n for n, d in G.nodes(data=True) if d.get('type') == 'drug']\n\n    # Draw nodes\n    nx.draw_networkx_nodes(G, pos, nodelist=gene_nodes, node_color='lightblue', node_size=800, label='Genes')\n    nx.draw_networkx_nodes(G, pos, nodelist=drug_nodes, node_color='lightgreen', node_size=600, label='Drugs')\n\n    # Draw edges\n    nx.draw_networkx_edges(G, pos, alpha=0.5)\n\n    # Draw labels\n    nx.draw_networkx_labels(G, pos, font_size=8, font_family='sans-serif')\n\n    plt.title(\"Gene-Drug Interaction Network (Personalized PGx)\", fontsize=16)\n    plt.legend()\n    plt.axis('off')\n\n    plt.savefig(output_path, format='png', dpi=300, bbox_inches='tight')\n    plt.close()\n    print(f\"Network plot saved to {output_path}\")\n</code></pre>"}]}